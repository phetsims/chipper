// Copyright 2025, University of Colorado Boulder

/**
 * FluentConstant is the type generated by generateFluentTypes for the entries in a SimFluent.ts file that require no inputs
 * for a pattern (i.e., constants that are interpolated using the fluent bundle but have no parameters).
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */

import { DerivedProperty1 } from '../../../axon/js/DerivedProperty.js';
import ReadOnlyProperty from '../../../axon/js/ReadOnlyProperty.js';
import { FluentBundle } from '../../../chipper/js/browser-and-node/FluentLibrary.js';
import PhetioObject from '../../../tandem/js/PhetioObject.js';
import chipper from './chipper.js';

const NO_STRING = '';

export default class FluentConstant extends DerivedProperty1<string, FluentBundle> {

  // For runtime "type checking" in PhetioObject. Note we cannot use instanceof FluentConstant there without causing a
  // cyclic dependency. This is used to help FluentConstant interoperate with the legacy phet-io instrumented string
  // requirements
  public override hasTargetProperty(): this is { targetProperty: PhetioObject } { return true; }

  /**
   * Creates a string Property that will update when the bundle changes.
   *
   * @param bundleProperty
   * @param key - The string key, where nesting is indicated by underscores (since that is compatible with Fluent syntax)
   *              such as a11y_summary_playAreaSummaryIntro
   * @param targetProperty - The target property that this FluentConstant will be associated with, solely for phet-io studio autoselect, see Text and RichText.
   *                       - this will be undefined in a built simulation when the corresponding string is unused.
   */
  public constructor( bundleProperty: ReadOnlyProperty<FluentBundle>,
                      key: string,
                      public readonly targetProperty: PhetioObject | undefined ) {

    super( [ bundleProperty ], bundle => {
      const message = bundle.getMessage( key );

      const errors: Array<Error> = [];

      // The message and value should be available during development. But the build removes unused strings.
      // FluentConstant is added to the Fluent.ts file during modulify so one will be created for all (even unused) keys.
      // Therefore, we must be graceful for the built simulation. We cannot assert or affirm because sometimes
      // assertions are kept in the build (like for debug).
      if ( message && message.value ) {
        const result = bundle.formatPattern( message.value, {}, errors );

        assert && assert( errors.length === 0, `Fluent errors found when formatting message: ${errors}` );
        return result;
      }
      else {
        return NO_STRING;
      }
    } );
  }
}

chipper.register( 'FluentConstant', FluentConstant );