// Copyright 2022-2024, University of Colorado Boulder

/**
 * Runs tasks for pre-commit, including lint and qunit testing.
 *
 * Should only be run when developing in main, because when dependency shas are checked out for one sim,
 * they will likely be inconsistent for other repos which would cause failures for cross-repo processes like type checking.
 * This means when running maintenance release steps, you may need to run git commands with --no-verify.
 *
 * Timing data is streamed through phetTimingLog, please see that file for how to see the results live and/or afterwards.
 *
 * USAGE:
 * cd ${repo}
 * sage run ../chipper/js/scripts/pre-commit.js
 *
 * OPTIONS:
 * --console: outputs information to the console for debugging
 * --force: forces all tasks to run, even if they are disabled in the local preferences
 *
 * TASKS:
 * --lint: runs eslint on the repo
 * --report-media: checks for missing or unused media files
 * --check: runs check.js
 * --test: runs qunit tests
 * --phet-io-api: compares the PhET-iO API with the previous version
 *
 * See also phet-info/git-template-dir/hooks/pre-commit for how this is used in precommit hooks.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import assert from 'assert';
import buildLocal from '../../../../perennial-alias/js/common/buildLocal.js';
import execute from '../../../../perennial-alias/js/common/execute.js';
import phetTimingLog from '../../../../perennial-alias/js/common/phetTimingLog.js';
import tsxCommand from '../../../../perennial-alias/js/common/tsxCommand.js';
import getRepo from '../../../../perennial-alias/js/grunt/tasks/util/getRepo.js';
import getOption, { isOptionKeyProvided } from '../../../../perennial-alias/js/grunt/tasks/util/getOption.js';

// These repos do not require precommit hooks to be run
const optOutRepos = [

  // The files here are predominantly autogenerated and unlikely to be broken. Also, every repo depends on babel
  // so running precommit hooks here takes a significant amount of time
  'babel'
];

const repo = getRepo();

const outputToConsole = getOption( 'console' ); // Console logging via --console

( async () => {

  if ( optOutRepos.includes( repo ) ) {
    console.log( `Skipping precommit hooks for the repo: ${repo}` );
    process.exit( 0 );
  }

  const possibleTasks = [ 'lint', 'report-media', 'check', 'test', 'phet-io-api' ];

  // By default, run all tasks
  let tasksToRun = [ ...possibleTasks ];
  const OPT_OUT_ALL = '*'; // Key to opt out of all tasks

  // check local preferences for overrides for which tasks to turn 'off'
  const hookPreCommit = buildLocal.hookPreCommit;
  if ( hookPreCommit && hookPreCommit[ OPT_OUT_ALL ] === false ) {
    outputToConsole && console.log( 'all tasks opted out from build-local.json' );
    tasksToRun.length = 0;
  }

  possibleTasks.forEach( ( task: string ) => {

    // process the buildLocal preferences first
    if ( hookPreCommit && hookPreCommit[ task ] === false ) {
      outputToConsole && console.log( 'task opted out from build-local.json:', task );
      tasksToRun = tasksToRun.filter( t => t !== task );
    }

    // process the CLI overrides
    if ( isOptionKeyProvided( task ) ) {
      if ( getOption( task ) ) {
        if ( !tasksToRun.includes( task ) ) {
          outputToConsole && console.log( 'task added from CLI:', task );
          tasksToRun.push( task );
        }
      }
      else {
        outputToConsole && console.log( 'task removed from CLI:', task );
        tasksToRun = tasksToRun.filter( t => t !== task );
      }
    }
  } );

  // TODO: This is kind of like * in the json, or --all. Is this a good API? See https://github.com/phetsims/perennial/issues/404
  if ( getOption( 'force' ) ) {
    outputToConsole && console.log( 'forcing all tasks to run' );
    tasksToRun = [ ...possibleTasks ];
  }

  outputToConsole && console.log( 'tasks to run:', tasksToRun );

  const precommitSuccess = await phetTimingLog.startAsync( `pre-commit repo="${repo}"`, async () => {

    outputToConsole && console.log( 'repo:', repo );

    const taskResults = await Promise.allSettled(
      tasksToRun.map( task => {
        return phetTimingLog.startAsync(
          task,
          async () => {
            const results = await execute(
              tsxCommand,
              [
                '../chipper/js/common/pre-commit-main.ts',
                `--command=${task}`,
                `--repo=${repo}`,
                outputToConsole ? '--console' : ''
              ],
              '../chipper',
              {
                errors: 'resolve'
              }
            );
            assert( typeof results !== 'string' );
            results.stdout && results.stdout.trim().length > 0 && console.log( results.stdout );
            results.stderr && results.stderr.trim().length > 0 && console.log( results.stderr );

            if ( results.code === 0 ) {
              return { task: task, success: true };
            }
            else {
              let message = 'Task failed: ' + task;
              if ( results.stdout && results.stdout.trim().length > 0 ) {
                message = message + ': ' + results.stdout;
              }
              if ( results.stderr && results.stderr.trim().length > 0 ) {
                message = message + ': ' + results.stderr;
              }
              return { task: task, success: false, message: message };
            }
          },
          {
            depth: 1
          }
        );
      } )
    );

    taskResults.forEach( result => {
      if ( result.status === 'fulfilled' ) {
        if ( result.value.success ) {
          console.log( `Task ${result.value.task} succeeded` );
        }
        else {
          console.error( result.value.message );
        }
      }
      else {
        console.error( `Task ${result.reason.task} encountered an error: ${result.reason.message}` );
      }
    } );

    return taskResults.every( result => result.status === 'fulfilled' && result.value.success );
  } );

  // generatePhetioMacroAPI is preventing exit for unknown reasons, so manually exit here
  phetTimingLog.close( () => process.exit( precommitSuccess ? 0 : 1 ) );
} )();