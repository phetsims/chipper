<!DOCTYPE HTML>
<!-- Top-level HTML file for viewing, generated by 'grunt generate-a11y-view-html' DO NOT EDIT THIS FILE ONCE BUILT-->
<html>
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="phet-sim-level" content="production">

  <!--have to scroll right and left! allows to resize also-->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A11y View</title>

  <style>
    html {
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.4;
    }

    body {
      margin: 1em;
      background: #ccc;
    }

    h1, h3, p {
      margin-top: .55em;
      margin-bottom: 0;
      padding: 0;
    }

    .alert_copy_container ul {
      -webkit-padding-start: 1.1em
    }

    .left {
      width: 47%;
      position: -webkit-sticky;
      position: sticky;
      top: .55em;
      display: inline-block;
    }

    /* This class was found online as a way to preserve an iframe aspect ratio,
    see https://fettblog.eu/blog/2013/06/16/preserving-aspect-ratio-for-embedded-iframes/*/

    iframe {
      width: 100%;
      position: fixed;
    }

    .aspect-ratio {
      position: relative;
      width: 100%;
      height: 0;
      padding-bottom: 69%;
    }

    .aspect-ratio iframe {
      position: absolute;
      width: 100%;
      height: 100%;
      left: 0;
      top: 0;
    }

    div.right {
      background: #ccc;
      float: right;
      width: 47%;
      overflow: auto;
    }

    div.clearfix {
      clear: both;
    }

    p.alert {
      opacity: 0.6;
    }

    div.alert_copy_container {
      background: #e5c45b;
      border-radius: 1em;
      padding: .25em .75em 1em;
      height: 10em;
      overflow-y: auto;
    }

    p.alert_copy {
      min-height: 5em;
    }

    div.dom_copy_container {
      background: #a0e1e7;
      border-radius: 1em;
      padding: 1em;
    }

    div.dom_copy_container li {
      margin-bottom: .5em;
    }

    div.wrapper {
      height: auto;
      width: 97%;
    }

    .dynamic {
      background-color: #9adaa6;
      border-bottom: double .167em #000; /*or a border in dark green*/
    }

    div#alerts, div#pdom {
      margin-bottom: 1.1em;
    }

    em { /* this is the same as the dynamic class, but should be changed as part of https://github.com/phetsims/a11y-research/issues/67*/
      background-color: #9adaa6;
      border-bottom: double .167em #000; /*or a border in dark green*/
    }

    .highlight {
      /*use outline instead of border because border doesn't apply to all DOMElements, add margin because outline
      doesn't take up any space*/
      outline: 6px double rgb(250,40,135);
      margin: 1%;
    }

    .bold {
      font-weight: bold;
    }

    .assertive {
      background-color: pink; /* do not change color without changing the doc in "About Interactive Alerts" */
      border-radius: .2em;
    }

    .activity-log-heading-container {
      display: flex;
      align-content: space-between;
      align-items: flex-start;
      justify-content: space-between;
      padding-top: 0.5em;
    }

    .activity-log-heading-item {
      align-self: center;
      font-size: 1.17em;
    }

    .view-mode-controls {
      display: flex;
      gap: 0.75em;
      flex-wrap: wrap;
      padding: 0.75em 1em 0.5em;
      background: #ecf4fb;
      border-radius: 0.75em;
      margin-bottom: 1em;
    }

    .view-mode-option {
      display: flex;
      align-items: center;
      gap: 0.35em;
      font-size: 0.95em;
    }

    .view-mode-option input[type="radio"] {
      accent-color: #0a74b9;
    }

    .dom-view {
      display: none;
    }

    .dom-view[data-active="true"] {
      display: block;
    }

    .dom-view[data-view="formatted"] {
      background: #fdfefe;
      border-radius: 0.75em;
      padding: 1em;
      box-shadow: 0 0 0 1px rgba(19, 69, 117, 0.08);
    }

    .dom-view[data-view="formatted"] > *:not(.formatted-group) + * {
      margin-top: 0.65em;
    }

    .formatted-group {
      border: 1px solid #cbd6e4;
      border-left: 4px solid #7ba5d9;
      border-radius: 0.6em;
      padding: 0.5em 0.25em;
      margin: 0 0 0.9em;
      background: #f6f9fd;
    }

    .formatted-group .formatted-group {
      margin-top: 0.65em;
      margin-bottom: 0;
      margin-left: 0.25em;
      background: #ffffff;
      border-left-color: #a8c4e6;
    }

    .formatted-aria-block {
      border-top: 1px dashed #cbd6e4;
      border-bottom: 1px dashed #cbd6e4;
      padding: 0.45em 0;
      margin: 0.45em 0;
    }

    .formatted-aria {
      font-size: 0.85em;
      color: #1b5fa7;
    }

    .formatted-aria-heading {
      margin: 0.55em 0 0;
      font-size: 0.92em;
      font-weight: normal;
      line-height: 1.4;
    }

    .formatted-aria-body {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3em;
      margin-top: 0.45em;
      color: #214d85;
    }

    .aria-chip {
      background: #eef4fc;
      border: 1px solid #b9cdea;
      border-radius: 999px;
      padding: 0.2em 0.6em;
      font-size: 0.78em;
      line-height: 1.4;
      word-break: break-word;
    }

    .formatted-group > *:first-child {
      margin-top: 0;
    }

    .formatted-group > *:last-child {
      margin-bottom: 0;
    }

    .development-container {
      font-family: "Courier New", Courier, monospace;
      background: #f7f9fc;
      color: #4b5f79;
      padding: 0.75em 1em;
      border-radius: 0.75em;
      box-shadow: inset 0 0 0 1px rgba(19, 69, 117, 0.08);
      overflow-x: auto;
      line-height: 1.45;
    }

    .development-line {
      white-space: pre;
      margin: 0;
      padding-left: 0;
    }

    .development-tag {
      color: #0033b3;
      font-weight: 600;
    }

    .development-attribute {
      color: #c1571a;
      font-weight: 600;
    }

    .development-attribute-value {
      color: #2c536d;
      font-weight: 400;
    }

    .development-text-node {
      color: #0b1726;
      font-weight: 600;
    }

    .development-focus-highlight {
      background: #ffe9b5;
      border-radius: 0.4em;
      box-shadow: inset 0 0 0 1px rgba(220, 157, 16, 0.6);
    }


    /* ************SAFARI ONLY *********************** */
    .left-safari {
      display: inline-block;
      width: 47%;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
  </style>

</head>
<body>

<div class="wrapper">

  <div id="content">
    <div id="intro">
      <h1>A11y View</h1>
      <details>
        <summary>About the A11y View Tool</summary>
        <p>
          The A11y View is a design and presentation tool that visually displays a copy of the descriptions we design
          for the Interactive Description feature. The State Descriptions (blue box) track the current state of the
          simulation. The Responsive Descriptions (orange box) deliver relevant changes in real time as they happen.
          Using this tool, designers can test and assess the descriptions during the design process without using a
          screen reader. Educators can also use this tool to see if the content of the descritpions meets their teaching
          and learning needs.
        </p>
        <p>
          <b>Please note:</b> The A11y View is not for learners. In learning contexts, screen reader users access the
          Interactive Desctiption feature using the same simulation as everyone else.
        </p>
      </details>
    </div>

    <!--The sim and alert containers will both be placed in here -->
    <div id="left" class="left">
      <div class="aspect-ratio">
        <iframe id="iframe" allowfullscreen scrolling="no" title="Interact with simulation"></iframe>
      </div>
      <div id="alerts">
        <div class="activity-log-heading-container">
          <h3 class="activity-log-heading-item">Activity log of Responsive Descriptions</h3>
          <button class="activity-log-heading-item" id="clear-activity-log-button">Clear Log</button>
        </div>
        <details>
          <summary>About Responsive Descriptions</summary>
          Responsive Descriptions are a combination of object responses, descriptions of changes made directly to
          interactive objects, and context responses, descriptions of changes to the surrounding context. Together, they
          are designed to deliver relevant changes in real time as they happen. The object and context responses powered
          by ARIA Live appear in the activity log below. The object responses for slider interactions are powered by the
          aria-valuetext attribute, and are found in grey text under slider interactions in the blue box.
        </details>
        <div id='alert-copy-container' class='alert_copy_container' role='presentation'>
          <div id='polite-element-container'>
            <ul class='alert_copy' id='alert-list'></ul>
          </div>
        </div>
      </div>
    </div>

    <!--The PDOM copy will be placed in this container -->
    <div class="right" id="right">
      <div id="pdom">
        <h3>State Descriptions</h3>
        <details>
          <summary>About State Descriptions</summary>
          State Descriptions are a combination of static state descriptions (descriptions that never change) and dynamic
          state descriptions (descriptions that update silently as the simulation changes). Together, they form a
          complete description of the current state at any given moment. These are the descriptions that a screen reader
          user can read through or review as they feel the need when they are accessing a simulation (i.e., not the A11y
          View tool).
        </details>
        <div class="dom_copy_container" role="presentation">
          <fieldset id="view-mode-controls" class="view-mode-controls" role="radiogroup" aria-label="View mode">
            <legend class="sr-only">Select view mode</legend>
            <label class="view-mode-option">
              <input type="radio" name="a11y-view-mode" value="formatted">
              Formatted view
            </label>
            <label class="view-mode-option">
              <input type="radio" name="a11y-view-mode" value="development">
              Development view
            </label>
            <label class="view-mode-option">
              <input type="radio" name="a11y-view-mode" value="legacy">
              Legacy view
            </label>
          </fieldset>
          <div id="dom-copy-container">
            <div class="dom-view" data-view="formatted"></div>
            <div class="dom-view" data-view="development"></div>
            <div class="dom-view" data-view="legacy"></div>
          </div>
        </div>
      </div>
    </div>

    <!--clear the blocks after the float effect-->
    <div class="clearfix"></div>
  </div>

</div>

<script type="application/javascript">
  ( () => {
    const IS_BUILT_STRING = '{{IS_BUILT}}';
    const IS_BUILT = IS_BUILT_STRING.indexOf( '{{' ) !== 0; // escape for better syntax highlighting support

    /**
     * Initializes the embedded simulation iframe by reading the search parameters, building the expected
     * simulation URL, and enabling sticky layout behavior once the iframe is configured.
     */
    function initializeSimulationFrame() {
      const simulationQueryString = new URLSearchParams( window.location.search );

      // TODO: This code is very PhET-sim specific, we would like a way to specify an arbitrary scenery-stack app
      // TODO: https://github.com/phetsims/chipper/issues/1512
      let sim = simulationQueryString.get( 'sim' );

      // Remove the sim query parameter from the URL so that it doesn't go to the iframe url
      simulationQueryString.delete( 'sim' );

      // Do not liveReload on the nested iframe, just in the outer a11y view.
      simulationQueryString.delete( 'liveReload' );

      // Append the required parameters.
      simulationQueryString.set( 'postMessageOnLoad', '' );
      simulationQueryString.set( 'postMessageOnError', '' );
      simulationQueryString.set( 'supportsInteractiveDescription', 'true' );

      // in unbuilt mode and on phet-server, the brand suffix is removed
      const filenameEnding = ( window.location.hostname === 'phet.colorado.edu' || !IS_BUILT ) ? '.html' : '_phet.html';

      if ( IS_BUILT ) {
        sim = '{{PHET_REPOSITORY}}';
      }
      if ( !sim ) {
        throw new Error( 'No sim query parameter provided' );
      }

      // Unbuilt sims include all locales in the en file, built versions only include all strings in the all file
      const simWithLocale = `${sim}_${IS_BUILT ? 'all' : 'en'}`;
      const iframe = document.getElementById( 'iframe' );
      if ( !iframe ) {
        return;
      }

      let simURL = `../../../${sim}/${simWithLocale}${filenameEnding}?${simulationQueryString}`;
      if ( IS_BUILT ) {
        simURL = `./${simWithLocale}${filenameEnding}?${simulationQueryString}`;
      }

      iframe.setAttribute( 'src', simURL );
      applyStickyBehavior();
    }

    initializeSimulationFrame();

    /**
     * Adds sticky positioning styles to the left column, accounting for Safari's non-standard behavior.
     */
    function applyStickyBehavior() {
      const left = document.getElementById( 'left' );
      if ( !left ) {
        return;
      }

      const ua = navigator.userAgent.toLowerCase();
      if ( ua.indexOf( 'safari' ) !== -1 ) {
        if ( ua.indexOf( 'chrome' ) > -1 ) {
          left.classList.add( 'left' );
        }
        else {
          left.classList.add( 'left-safari' );
        }
      }
    }
  } )();
</script>

<script>
  ( () => {
    // Number of alerts that remain in the Activity log
    const ACTIVITY_LOG_LENGTH = 40;

    // Helpers to keep shouldDisplay predicates readable when filtering ARIA attributes.
    const DISPLAY_WHEN_TRUE = value => value === 'true';
    const DISPLAY_WHEN_NOT_FALSE = value => value !== 'false';
    const DISPLAY_WHEN_PRESENT = value => value && value.trim().length > 0;
    const RELATIONSHIP_PLACEHOLDER = '...';

    /**
     * Formats the value for an ARIA attribute using optional value formatting metadata.
     *
     * @param {{ name: string, shouldDisplay?: function(string, HTMLElement): boolean, formatValue?: function(string, HTMLElement): string }} config
     * @param {string} value
     * @param {HTMLElement} element
     * @returns {string}
     */
    function formatAriaValue( config, value, element ) {
      if ( config.formatValue ) {
        return config.formatValue( value, element );
      }
      return value;
    }

    // The attributes that we want to display as additional data in the PDOM copy. Otherwise, these are invisible
    // unless you inspect the DOM. For each entry, you can provide a shouldDisplay predicate that will control
    // how it is shown.
    const IMPORTANT_ARIA_ATTRIBUTES = [
      // Roles and semantics
      { name: 'role' },
      { name: 'aria-roledescription', shouldDisplay: DISPLAY_WHEN_PRESENT },

      // Relationships and labelling
      { name: 'aria-labelledby', shouldDisplay: DISPLAY_WHEN_PRESENT, formatValue: () => RELATIONSHIP_PLACEHOLDER },
      { name: 'aria-describedby', shouldDisplay: DISPLAY_WHEN_PRESENT, formatValue: () => RELATIONSHIP_PLACEHOLDER },
      { name: 'aria-controls', shouldDisplay: DISPLAY_WHEN_PRESENT, formatValue: () => RELATIONSHIP_PLACEHOLDER },
      { name: 'aria-owns', shouldDisplay: DISPLAY_WHEN_PRESENT, formatValue: () => RELATIONSHIP_PLACEHOLDER },
      {
        name: 'aria-activedescendant',
        shouldDisplay: DISPLAY_WHEN_PRESENT,
        formatValue: () => RELATIONSHIP_PLACEHOLDER
      },

      // Visibility and modality
      { name: 'aria-hidden', shouldDisplay: DISPLAY_WHEN_TRUE },
      { name: 'aria-modal', shouldDisplay: DISPLAY_WHEN_TRUE },

      // Widget state
      { name: 'aria-expanded' },
      { name: 'aria-pressed' },
      { name: 'aria-checked' },
      { name: 'aria-selected', shouldDisplay: DISPLAY_WHEN_TRUE },
      { name: 'aria-current', shouldDisplay: DISPLAY_WHEN_NOT_FALSE },
      { name: 'aria-haspopup', shouldDisplay: DISPLAY_WHEN_NOT_FALSE },
      { name: 'aria-required', shouldDisplay: DISPLAY_WHEN_TRUE },
      { name: 'aria-invalid', shouldDisplay: DISPLAY_WHEN_NOT_FALSE },
      { name: 'aria-readonly', shouldDisplay: DISPLAY_WHEN_TRUE },
      { name: 'aria-disabled', shouldDisplay: DISPLAY_WHEN_TRUE },

      // Live region hints
      { name: 'aria-live', shouldDisplay: value => value && value !== 'off' },
      { name: 'aria-atomic', shouldDisplay: DISPLAY_WHEN_TRUE },

      // Orientation and range metadata
      { name: 'aria-orientation', shouldDisplay: DISPLAY_WHEN_PRESENT },
      { name: 'aria-valuenow' },
      { name: 'aria-valuemin' },
      { name: 'aria-valuemax' },
      { name: 'aria-valuetext' },

      // Set membership
      { name: 'aria-level', shouldDisplay: DISPLAY_WHEN_PRESENT },
      { name: 'aria-posinset', shouldDisplay: DISPLAY_WHEN_PRESENT },
      { name: 'aria-setsize', shouldDisplay: DISPLAY_WHEN_PRESENT },

      // Busy state
      { name: 'aria-busy', shouldDisplay: DISPLAY_WHEN_TRUE }
    ];

    const VIEW_MODES = {
      FORMATTED: 'formatted',
      DEVELOPMENT: 'development',
      LEGACY: 'legacy'
    };

    const VIEW_MODE_STORAGE_KEY = 'a11y-view-mode';
    const DEFAULT_VIEW_MODE = VIEW_MODES.FORMATTED;

    const DEVELOPMENT_ALLOWED_ATTRIBUTES = new Set( [
      'role',
      'type',
      'name',
      'value',
      'checked',
      'disabled',
      'required',
      'hidden',
      'tabindex',
      'title',
      'alt',
      'lang',
      'for',
      'placeholder',
      'min',
      'max',
      'step'
    ] );

    const VOID_ELEMENTS = new Set( [
      'area',
      'base',
      'br',
      'col',
      'embed',
      'hr',
      'img',
      'input',
      'link',
      'meta',
      'param',
      'source',
      'track',
      'wbr'
    ] );

    const DEVELOPMENT_INDENT_SIZE_EM = 1.25;
    const INLINE_SINGLE_LINE_TAGS = new Set( [
      'a',
      'abbr',
      'button',
      'code',
      'em',
      'label',
      'small',
      'span',
      'strong'
    ] );
    const DEVELOPMENT_INLINE_TEXT_LIMIT = 80;
    const DEVELOPMENT_SOURCE_ID_SYMBOL = Symbol( 'a11yViewSourceNodeId' );
    let developmentSourceIdCounter = 0;
    let developmentLineLookup = new Map();
    let developmentFocusLines = [];
    const DEVELOPMENT_FOCUS_CLASS = 'development-focus-highlight';
    let currentFocusedElement = null;

    const domReferences = createDomReferences();
    const viewContainers = createViewContainers( domReferences.domCopyContainer );
    const viewRenderers = {
      [ VIEW_MODES.FORMATTED ]: renderFormattedView,
      [ VIEW_MODES.DEVELOPMENT ]: renderDevelopmentView,
      [ VIEW_MODES.LEGACY ]: renderLegacyView
    };

    const MUTATION_OBSERVER_CONFIG = {
      attributes: true,
      childList: true,
      characterData: true,
      subtree: true
    };

    initializeViewModeControls( domReferences.viewModeControls, viewContainers );
    initializeActivityLogButton( domReferences.clearActivityLogButton, domReferences.alertList );
    setupMessageListener( domReferences, viewContainers, viewRenderers, MUTATION_OBSERVER_CONFIG );
    initializeLiveReload();

    /*******************************************************************************
     * Helper Functions
     */

    /**
     * Get all 'element' nodes off the parent element, placing them in an array for easy traversal.  Note that this
     * includes all elements, even those that are 'hidden' or purely for structure.
     *
     * @param  {HTMLElement} ancestor - parent whose children will be linearized
     * @returns {HTMLElement[]}
     */
    function getAllDOMElementsAsLinear( ancestor ) {

      // gets ALL descendant children for the element
      const children = ancestor.getElementsByTagName( '*' );

      const linearDOM = [];
      for ( let i = 0; i < children.length; i++ ) {

        // searching for the HTML element nodes (NOT Scenery nodes)
        if ( children[ i ].nodeType === Node.ELEMENT_NODE ) {
          linearDOM[ i ] = ( children[ i ] );
        }
      }
      return linearDOM;
    }

    /**
     * Apply the necessary styling to the PDOM copy so that it looks and behaves well. This includes removing from
     * navigation order and ensuring that all of the styling copied from the actual PDOM is removed so that the copy
     * is visible and elements have proper dimensions.
     *
     * @param {HTMLElement} root - ancestor element, this and all descendants will be styled
     */
    function styleCopy( root ) {
      const allElements = getAllDOMElementsAsLinear( root );

      for ( let i = 0; i < allElements.length; i++ ) {
        const element = allElements[ i ];

        // make sure nothing in copy is focusable
        element.tabIndex = '-1';

        // make sure that styling is removed, unless some styling was added just for the copy
        if ( element.className !== 'pdom-style' ) {
          element.removeAttribute( 'style' );
        }
      }
    }

    /**
     * Updates the data-active attribute for view containers so that only the selected view is marked active.
     *
     * @param {Object.<string, HTMLElement|null>} viewContainers
     * @param {string} viewMode
     */
    function setActiveView( viewContainers, viewMode ) {
      Object.keys( viewContainers ).forEach( key => {
        const container = viewContainers[ key ];
        if ( !container ) {
          return;
        }
        if ( key === viewMode ) {
          container.setAttribute( 'data-active', 'true' );
        }
        else {
          container.removeAttribute( 'data-active' );
        }
      } );
    }

    /**
     * Loads the persisted view mode preference from localStorage, falling back to the default on failure.
     *
     * @returns {string}
     */
    function loadViewMode() {
      try {
        const value = localStorage.getItem( VIEW_MODE_STORAGE_KEY );
        if ( value && Object.values( VIEW_MODES ).includes( value ) ) {
          return value;
        }
      }
      catch( e ) {
        // ignore storage errors, fall back to default
      }
      return DEFAULT_VIEW_MODE;
    }

    /**
     * Persists the current view mode selection to localStorage, intentionally ignoring storage failures.
     *
     * @param {string} viewMode
     */
    function storeViewMode( viewMode ) {
      try {
        localStorage.setItem( VIEW_MODE_STORAGE_KEY, viewMode );
      }
      catch( e ) {
        // ignore storage failures
      }
    }

    /**
     * Wires up the view mode radio group so that selections update the active DOM view and persisted preference.
     *
     * @param {HTMLElement|null} controls
     * @param {Object.<string, HTMLElement|null>} viewContainers
     * @returns {string} The mode that is active after initialization.
     */
    function initializeViewModeControls( controls, viewContainers ) {
      if ( !controls ) {
        return DEFAULT_VIEW_MODE;
      }

      const radioButtons = controls.querySelectorAll( 'input[name="a11y-view-mode"]' );
      let currentMode = loadViewMode();

      radioButtons.forEach( radio => {
        if ( radio.value === currentMode ) {
          radio.checked = true;
        }

        radio.addEventListener( 'change', event => {
          if ( event.target.checked ) {
            currentMode = event.target.value;
            storeViewMode( currentMode );
            setActiveView( viewContainers, currentMode );
          }
        } );
      } );

      if ( !Array.from( radioButtons ).some( radio => radio.checked ) ) {
        const firstRadio = Array.from( radioButtons )[ 0 ];
        if ( firstRadio ) {
          currentMode = firstRadio.value;
          firstRadio.checked = true;
        }
      }

      setActiveView( viewContainers, currentMode );
      return currentMode;
    }

    /**
     * Renders an unmodified copy of the PDOM into the legacy view container.
     *
     * @param {HTMLElement} pdomRoot
     * @param {HTMLElement|null} container
     */
    function renderLegacyView( pdomRoot, container ) {
      if ( !container ) {
        return;
      }
      container.innerHTML = '';
      const pdomCopy = pdomRoot.cloneNode( true );
      pdomCopy.removeAttribute( 'style' );
      container.appendChild( pdomCopy );
      addInlineAttributesTHTML( pdomCopy );
      styleCopy( pdomCopy );
    }

    // Elements that exist purely for document structure; we flatten them when building the formatted view.
    const DECORATOR_TAGS = new Set( [ 'SECTION', 'ARTICLE', 'MAIN', 'ASIDE' ] );

    /**
     * Renders a formatted, human-friendly representation of the PDOM structure.
     *
     * @param {HTMLElement} pdomRoot
     * @param {HTMLElement|null} container
     */
    function renderFormattedView( pdomRoot, container ) {
      if ( !container ) {
        return;
      }
      container.innerHTML = '';
      const fragment = document.createDocumentFragment();
      appendFormattedContent( pdomRoot, fragment );

      if ( fragment.childNodes.length === 0 ) {
        const emptyMessage = document.createElement( 'p' );
        emptyMessage.textContent = 'No accessible content available.';
        fragment.appendChild( emptyMessage );
      }

      container.appendChild( fragment );
    }

    /**
     * Determines whether an element should be omitted from the formatted view.
     *
     * @param {HTMLElement} element
     * @returns {boolean}
     */
    function shouldSkipFormattedElement( element ) {
      if ( !element || element.nodeType !== Node.ELEMENT_NODE ) {
        return true;
      }
      if ( element.hidden || element.getAttribute( 'aria-hidden' ) === 'true' ) {
        return true;
      }
      const tagName = element.tagName;
      return tagName === 'SCRIPT' || tagName === 'STYLE' || tagName === 'TEMPLATE';
    }

    /**
     * Recursively walks the PDOM subtree and appends a lightly-processed clone into the formatted container.
     *
     * @param {HTMLElement|DocumentFragment} sourceParent - Node within the live PDOM that we are mirroring.
     * @param {HTMLElement|DocumentFragment} targetParent - Destination container in the formatted view.
     */
    function appendFormattedContent( sourceParent, targetParent ) {
      const nodes = Array.from( sourceParent.childNodes );
      let index = 0;

      while ( index < nodes.length ) {
        const node = nodes[ index ];

        if ( node.nodeType === Node.TEXT_NODE ) {
          appendFormattedTextNode( node, targetParent );
          index++;
          continue;
        }

        if ( node.nodeType !== Node.ELEMENT_NODE ) {
          index++;
          continue;
        }

        const element = node;
        if ( shouldSkipFormattedElement( element ) ) {
          index++;
          continue;
        }

        const headingLevel = getHeadingLevel( element );
        if ( headingLevel !== null ) {
          index = appendHeadingGroup( nodes, index, headingLevel, targetParent );
          continue;
        }

        appendFormattedNode( element, targetParent );
        index++;
      }
    }

    /**
     * Creates a grouped block starting with the heading at startIndex and including following siblings until another
     * heading of the same or higher level appears.
     *
     * @param {Node[]} nodes - Child nodes belonging to the current parent in the source PDOM.
     * @param {number} startIndex - Index of the heading that initiated this group.
     * @param {number} headingLevel - Numeric heading level (1-6) for the initiating heading.
     * @param {HTMLElement|DocumentFragment} targetParent - Destination container for the grouped content.
     * @returns {number} Index of the next node to process in the caller's loop.
     */
    function appendHeadingGroup( nodes, startIndex, headingLevel, targetParent ) {
      const groupContainer = document.createElement( 'div' );
      groupContainer.className = 'formatted-group';

      let index = startIndex;
      while ( index < nodes.length ) {
        const current = nodes[ index ];

        if ( current.nodeType === Node.TEXT_NODE ) {
          appendFormattedTextNode( current, groupContainer );
          index++;
          continue;
        }

        if ( current.nodeType !== Node.ELEMENT_NODE ) {
          index++;
          continue;
        }

        const element = current;
        if ( shouldSkipFormattedElement( element ) ) {
          index++;
          continue;
        }

        const currentHeadingLevel = getHeadingLevel( element );
        // Stop once we reach a heading that should belong to an outer group.
        if ( index !== startIndex && currentHeadingLevel !== null && currentHeadingLevel <= headingLevel ) {
          break;
        }

        appendFormattedNode( element, groupContainer );
        index++;
      }

      if ( groupContainer.childNodes.length > 0 ) {
        targetParent.appendChild( groupContainer );
      }

      return index;
    }

    /**
     * Clones a PDOM element into the formatted view, skipping decorator elements and removing unwanted styling.
     *
     * @param {HTMLElement} sourceElement - Element from the live PDOM.
     * @param {HTMLElement|DocumentFragment} targetParent - Container in the formatted view.
     */
    function appendFormattedNode( sourceElement, targetParent ) {
      if ( isDecoratorElement( sourceElement ) ) {
        appendFormattedContent( sourceElement, targetParent );
        return;
      }

      const clone = cloneFormattedElement( sourceElement );
      targetParent.appendChild( clone );
      appendFormattedContent( sourceElement, clone );
      appendFormattedAriaDetails( sourceElement, clone );
      finalizeFormattedElement( sourceElement, clone );
    }

    /**
     * Copies a text node into the formatted view, trimming and collapsing whitespace while preserving deliberate
     * leading/trailing spaces.
     *
     * @param {Text} textNode - Source text node from the PDOM.
     * @param {HTMLElement|DocumentFragment} targetParent - Destination container.
     */
    function appendFormattedTextNode( textNode, targetParent ) {
      if ( !textNode ) {
        return;
      }

      const content = textNode.textContent;
      if ( !content ) {
        return;
      }

      const collapsed = content.replace( /\s+/g, ' ' );
      const trimmed = collapsed.trim();
      if ( trimmed.length === 0 ) {
        return;
      }

      const needsLeadingSpace = /^\s/.test( content );
      const needsTrailingSpace = /\s$/.test( content );
      const finalText = `${needsLeadingSpace ? ' ' : ''}${trimmed}${needsTrailingSpace ? ' ' : ''}`;
      targetParent.appendChild( document.createTextNode( finalText ) );
    }

    /**
     * Creates a shallow clone for a source element, removing inline styling and neutralising focus management.
     *
     * @param {HTMLElement} sourceElement - Element from the live PDOM.
     * @returns {HTMLElement} Shallow clone ready to receive child content.
     */
    function cloneFormattedElement( sourceElement ) {
      const clone = sourceElement.cloneNode( false );
      clone.removeAttribute( 'style' );
      clone.tabIndex = -1;

      // Grouping names assigned in the simulation will not work when all cloned elements are in the same document.
      clone.removeAttribute( 'name' );
      return clone;
    }

    /**
     * Collects ARIA attributes that should be surfaced in the formatted view, respecting per-attribute filters.
     *
     * @param {HTMLElement} element
     * @returns {{ name: string, value: string }[]}
     */
    function collectImportantAriaAttributes( element ) {
      const attributes = [];

      IMPORTANT_ARIA_ATTRIBUTES.forEach( attributeDefinition => {
        const config = typeof attributeDefinition === 'string' ? { name: attributeDefinition } : attributeDefinition;
        const attributeName = config.name;
        const shouldDisplay = config.shouldDisplay;

        if ( element.hasAttribute( attributeName ) ) {
          const value = element.getAttribute( attributeName );

          if ( shouldDisplay && !shouldDisplay( value, element ) ) {
            return;
          }

          attributes.push( {
            name: attributeName,
            value: formatAriaValue( config, value, element )
          } );
        }
      } );

      return attributes;
    }

    /**
     * Appends ARIA attribute chips for the supplied element directly after its clone in the formatted view.
     *
     * @param {HTMLElement} sourceElement
     * @param {HTMLElement} clone
     */
    function appendFormattedAriaDetails( sourceElement, clone ) {
      const attributes = collectImportantAriaAttributes( sourceElement );
      if ( attributes.length === 0 ) {
        return;
      }

      const parent = clone.parentNode;
      if ( !parent ) {
        return;
      }

      const insertionPoint = clone.nextSibling;

      const wrapper = document.createElement( 'div' );
      wrapper.className = 'formatted-aria-block';

      const ariaContainer = document.createElement( 'div' );
      ariaContainer.className = 'formatted-aria';

      const heading = document.createElement( 'div' );
      heading.className = 'formatted-aria-heading';
      heading.textContent = `ARIA details (${attributes.length})`;
      ariaContainer.appendChild( heading );

      const body = document.createElement( 'div' );
      body.className = 'formatted-aria-body';

      attributes.forEach( attribute => {
        const chip = document.createElement( 'span' );
        chip.className = 'aria-chip';
        chip.textContent = `${attribute.name}: ${attribute.value}`;
        body.appendChild( chip );
      } );

      ariaContainer.appendChild( body );
      wrapper.appendChild( clone );
      wrapper.appendChild( ariaContainer );

      if ( insertionPoint ) {
        parent.insertBefore( wrapper, insertionPoint );
      }
      else {
        parent.appendChild( wrapper );
      }
    }

    /**
     * Performs post-recursion adjustments that require access to the source element's descendants (e.g. option state).
     *
     * @param {HTMLElement} sourceElement
     * @param {HTMLElement} clone
     */
    function finalizeFormattedElement( sourceElement, clone ) {
      const tagName = sourceElement.tagName.toLowerCase();

      if ( tagName === 'select' ) {
        clone.selectedIndex = sourceElement.selectedIndex;
        return;
      }

      if ( tagName === 'option' ) {
        if ( sourceElement.selected ) {
          clone.selected = true;
        }
        return;
      }

      if ( tagName === 'textarea' ) {
        clone.value = sourceElement.value || sourceElement.textContent || '';
      }
    }

    /**
     * Extracts the heading level for an element, supporting native heading tags, role=heading, and id patterns.
     *
     * @param {HTMLElement} element
     * @returns {number|null}
     */
    function getHeadingLevel( element ) {
      const tagName = element.tagName.toLowerCase();
      if ( /^h[1-6]$/.test( tagName ) ) {
        return Number( tagName.charAt( 1 ) );
      }

      const role = ( element.getAttribute( 'role' ) || '' ).toLowerCase();
      if ( role === 'heading' ) {
        const ariaLevel = parseInt( element.getAttribute( 'aria-level' ), 10 );
        if ( !Number.isNaN( ariaLevel ) ) {
          return ariaLevel;
        }
        return 2;
      }

      if ( element.id && element.id.indexOf( '-heading-' ) >= 0 ) {
        const ariaLevel = parseInt( element.getAttribute( 'aria-level' ), 10 );
        if ( !Number.isNaN( ariaLevel ) ) {
          return ariaLevel;
        }
        if ( /^h[1-6]$/.test( tagName ) ) {
          return Number( tagName.charAt( 1 ) );
        }
        return 2;
      }

      return null;
    }

    /**
     * Determines whether an element exists purely for structure and should be flattened in the formatted view.
     *
     * @param {HTMLElement} element
     * @returns {boolean}
     */
    function isDecoratorElement( element ) {
      return DECORATOR_TAGS.has( element.tagName );
    }

    /**
     * Renders a sanitized, code-like representation of the PDOM structure for development analysis.
     *
     * @param {HTMLElement} pdomRoot
     * @param {HTMLElement|null} container
     */
    function renderDevelopmentView( pdomRoot, container ) {
      if ( !container ) {
        return;
      }
      clearDevelopmentFocusHighlight();
      container.innerHTML = '';

      const wrapper = document.createElement( 'div' );
      wrapper.className = 'development-container';

      const workingCopy = pdomRoot.cloneNode( true );
      annotateDevelopmentClone( pdomRoot, workingCopy );
      sanitizeForDevelopmentView( workingCopy );

      developmentLineLookup = new Map();

      const topLevelElements = Array.from( workingCopy.children );
      topLevelElements.forEach( element => renderDevelopmentNode( element, wrapper, 0 ) );

      if ( wrapper.childNodes.length === 0 ) {
        wrapper.textContent = 'No accessible markup available.';
      }

      container.appendChild( wrapper );
      refreshDevelopmentFocusHighlight();
    }

    /**
     * Copies source node metadata onto clone nodes so the development view can trace back to the live PDOM.
     *
     * @param {Node} sourceRoot
     * @param {Node} cloneRoot
     */
    function annotateDevelopmentClone( sourceRoot, cloneRoot ) {
      if ( !sourceRoot || !cloneRoot ) {
        return;
      }
      if ( sourceRoot.nodeType !== Node.ELEMENT_NODE || cloneRoot.nodeType !== Node.ELEMENT_NODE ) {
        return;
      }

      const sourceElements = [ sourceRoot, ...sourceRoot.getElementsByTagName( '*' ) ];
      const cloneElements = [ cloneRoot, ...cloneRoot.getElementsByTagName( '*' ) ];
      const count = Math.min( sourceElements.length, cloneElements.length );

      for ( let i = 0; i < count; i++ ) {
        const sourceElement = sourceElements[ i ];
        const cloneElement = cloneElements[ i ];
        if ( !sourceElement || !cloneElement ) {
          continue;
        }
        const id = generateDevelopmentSourceId( sourceElement );
        cloneElement[ DEVELOPMENT_SOURCE_ID_SYMBOL ] = id;
      }
    }

    /**
     * Generates or retrieves a stable ID used to associate development view lines with source elements.
     *
     * @param {HTMLElement} element
     * @returns {string|null}
     */
    function generateDevelopmentSourceId( element ) {
      if ( !element ) {
        return null;
      }
      let id = element[ DEVELOPMENT_SOURCE_ID_SYMBOL ];
      if ( !id ) {
        developmentSourceIdCounter += 1;
        id = `a11y-node-${developmentSourceIdCounter}`;
        element[ DEVELOPMENT_SOURCE_ID_SYMBOL ] = id;
      }
      return id;
    }

    /**
     * Tracks rendered development lines so they can be highlighted in response to focus changes.
     *
     * @param {string|null} sourceId
     * @param {HTMLElement} line
     */
    function registerDevelopmentLine( sourceId, line ) {
      if ( !sourceId || !line ) {
        return;
      }
      let lines = developmentLineLookup.get( sourceId );
      if ( !lines ) {
        lines = [];
        developmentLineLookup.set( sourceId, lines );
      }
      lines.push( line );
    }

    /**
     * Removes the visual highlight from any development view lines that are currently emphasized.
     */
    function clearDevelopmentFocusHighlight() {
      if ( developmentFocusLines.length === 0 ) {
        return;
      }
      developmentFocusLines.forEach( line => line.classList.remove( DEVELOPMENT_FOCUS_CLASS ) );
      developmentFocusLines = [];
    }

    /**
     * Highlights the development view lines that correspond to the provided source node ID.
     *
     * @param {string|null} sourceId
     */
    function applyDevelopmentFocusHighlight( sourceId ) {
      clearDevelopmentFocusHighlight();
      if ( !sourceId ) {
        return;
      }
      const lines = developmentLineLookup.get( sourceId );
      if ( !lines || lines.length === 0 ) {
        return;
      }
      lines.forEach( line => line.classList.add( DEVELOPMENT_FOCUS_CLASS ) );
      developmentFocusLines = lines.slice();
    }

    /**
     * Reapplies focus highlighting based on the iframe's currently focused element.
     */
    function refreshDevelopmentFocusHighlight() {
      if ( !currentFocusedElement ) {
        clearDevelopmentFocusHighlight();
        return;
      }
      const sourceId = currentFocusedElement[ DEVELOPMENT_SOURCE_ID_SYMBOL ];
      if ( !sourceId ) {
        clearDevelopmentFocusHighlight();
        return;
      }
      applyDevelopmentFocusHighlight( sourceId );
    }

    /**
     * Cleans and normalizes the cloned PDOM so that the development view focuses on semantic markup.
     *
     * @param {HTMLElement} root
     */
    function sanitizeForDevelopmentView( root ) {

      // Remove hidden elements entirely from the view.
      Array.from( root.querySelectorAll( '[hidden]' ) ).forEach( element => {
        if ( element.parentNode ) {
          element.parentNode.removeChild( element );
        }
      } );

      const walker = document.createTreeWalker( root, NodeFilter.SHOW_ELEMENT, null );
      while ( walker.nextNode() ) {
        sanitizeElement( walker.currentNode );
      }
    }

    /**
     * Removes non-essential attributes and masks sensitive references on a cloned element.
     *
     * @param {HTMLElement} element
     */
    function sanitizeElement( element ) {
      Array.from( element.attributes ).forEach( attribute => {
        const name = attribute.name;
        const value = attribute.value;

        if ( name === 'class' || name === 'style' || name.startsWith( 'data-' ) ) {
          element.removeAttribute( name );
          return;
        }

        if ( name === 'id' || name === 'hidden' ) {
          element.removeAttribute( name );
          return;
        }

        if ( name.startsWith( 'aria-' ) || DEVELOPMENT_ALLOWED_ATTRIBUTES.has( name ) ) {
          if ( ( name === 'aria-describedby' || name === 'aria-labelledby' || name === 'aria-controls' || name === 'aria-owns' || name === 'aria-activedescendant' || name === 'for' ) && value ) {
            element.setAttribute( name, '...' );
          }
          return;
        }

        element.removeAttribute( name );
      } );
    }

    /**
     * Renders a single DOM element (and its descendants) into the development view line-by-line.
     *
     * @param {HTMLElement} element
     * @param {HTMLElement} container
     * @param {number} depth
     */
    function renderDevelopmentNode( element, container, depth ) {
      const tagName = element.tagName.toLowerCase();
      const indent = `${depth * DEVELOPMENT_INDENT_SIZE_EM}em`;

      const openLine = document.createElement( 'div' );
      openLine.className = 'development-line';
      openLine.style.paddingLeft = indent;
      openLine.appendChild( createTagSpan( `<${tagName}` ) );

      const attributes = Array.from( element.attributes ).sort( ( a, b ) => a.name.localeCompare( b.name ) );
      attributes.forEach( attribute => appendAttributeTokens( openLine, attribute ) );

      const sourceId = element[ DEVELOPMENT_SOURCE_ID_SYMBOL ];
      if ( sourceId ) {
        openLine.dataset.sourceNodeId = sourceId;
        registerDevelopmentLine( sourceId, openLine );
      }

      if ( VOID_ELEMENTS.has( tagName ) ) {
        openLine.appendChild( createTagSpan( ' />' ) );
        container.appendChild( openLine );
        return;
      }

      const inlineTextContent = getCollapsedTextContent( element );
      if ( shouldRenderInlineElement( element, inlineTextContent ) ) {
        openLine.appendChild( createTagSpan( '>' ) );

        const textSpan = document.createElement( 'span' );
        textSpan.className = 'development-text-node';
        textSpan.textContent = inlineTextContent;
        openLine.appendChild( textSpan );

        openLine.appendChild( createTagSpan( `</${tagName}>` ) );
        container.appendChild( openLine );
        return;
      }

      openLine.appendChild( createTagSpan( '>' ) );
      container.appendChild( openLine );

      Array.from( element.childNodes ).forEach( node => {
        if ( node.nodeType === Node.ELEMENT_NODE ) {
          renderDevelopmentNode( node, container, depth + 1 );
        }
        else if ( node.nodeType === Node.TEXT_NODE ) {
          renderDevelopmentTextNode( node, container, depth );
        }
      } );

      const closeLine = document.createElement( 'div' );
      closeLine.className = 'development-line';
      closeLine.style.paddingLeft = indent;
      closeLine.appendChild( createTagSpan( `</${tagName}>` ) );
      if ( sourceId ) {
        closeLine.dataset.sourceNodeId = sourceId;
        registerDevelopmentLine( sourceId, closeLine );
      }
      container.appendChild( closeLine );
    }

    /**
     * Builds a span element styled as a markup tag for the development view.
     *
     * @param {string} text
     * @returns {HTMLSpanElement}
     */
    function createTagSpan( text ) {
      const span = document.createElement( 'span' );
      span.className = 'development-tag';
      span.textContent = text;
      return span;
    }

    /**
     * Appends styled attribute tokens (name/value) to the provided development line.
     *
     * @param {HTMLElement} line
     * @param {Attr} attribute
     */
    function appendAttributeTokens( line, attribute ) {
      line.appendChild( document.createTextNode( ' ' ) );

      const nameSpan = document.createElement( 'span' );
      nameSpan.className = 'development-attribute';
      nameSpan.textContent = attribute.name;
      line.appendChild( nameSpan );

      if ( attribute.value ) {
        const equalsSpan = document.createElement( 'span' );
        equalsSpan.className = 'development-tag';
        equalsSpan.textContent = '=';
        line.appendChild( equalsSpan );

        const valueSpan = document.createElement( 'span' );
        valueSpan.className = 'development-attribute-value';
        valueSpan.textContent = `"${attribute.value}"`;
        line.appendChild( valueSpan );
      }
    }

    /**
     * Renders a text node in the development view, collapsing whitespace for readability.
     *
     * @param {Text} node
     * @param {HTMLElement} container
     * @param {number} depth
     */
    function renderDevelopmentTextNode( node, container, depth ) {
      const content = node.textContent.replace( /\s+/g, ' ' ).trim();
      if ( !content ) {
        return;
      }

      const textLine = document.createElement( 'div' );
      textLine.className = 'development-line';
      textLine.style.paddingLeft = `${( depth + 1 ) * DEVELOPMENT_INDENT_SIZE_EM}em`;

      const span = document.createElement( 'span' );
      span.className = 'development-text-node';
      span.textContent = content;
      textLine.appendChild( span );
      container.appendChild( textLine );
    }

    /**
     * Returns the whitespace-collapsed text content of an element's immediate text children.
     *
     * @param {HTMLElement} element
     * @returns {string}
     */
    function getCollapsedTextContent( element ) {
      const text = Array.from( element.childNodes )
        .filter( node => node.nodeType === Node.TEXT_NODE )
        .map( node => node.textContent || '' )
        .join( ' ' )
        .replace( /\s+/g, ' ' )
        .trim();
      return text;
    }

    /**
     * Determines whether an element should be rendered inline (opening tag, text, closing tag on one line).
     *
     * @param {HTMLElement} element
     * @param {string} textContent
     * @returns {boolean}
     */
    function shouldRenderInlineElement( element, textContent ) {
      if ( element.childElementCount > 0 ) {
        return false;
      }
      if ( !textContent ) {
        return false;
      }
      if ( textContent.length > DEVELOPMENT_INLINE_TEXT_LIMIT ) {
        return false;
      }

      const tagName = element.tagName.toLowerCase();
      return INLINE_SINGLE_LINE_TAGS.has( tagName ) || element.childNodes.length === 1;
    }

    /**
     * Executes each registered renderer to populate the DOM view containers with up-to-date content.
     *
     * @param {HTMLElement} pdomRoot
     * @param {Object.<string, HTMLElement|null>} viewContainers
     * @param {Object.<string, Function>} renderers
     */
    function renderViews( pdomRoot, viewContainers, renderers ) {
      if ( !renderers ) {
        return;
      }

      const formattedRenderer = renderers[ VIEW_MODES.FORMATTED ];
      if ( typeof formattedRenderer === 'function' ) {
        formattedRenderer( pdomRoot, viewContainers[ VIEW_MODES.FORMATTED ] );
      }

      const developmentRenderer = renderers[ VIEW_MODES.DEVELOPMENT ];
      if ( typeof developmentRenderer === 'function' ) {
        developmentRenderer( pdomRoot, viewContainers[ VIEW_MODES.DEVELOPMENT ] );
      }

      const legacyRenderer = renderers[ VIEW_MODES.LEGACY ];
      if ( typeof legacyRenderer === 'function' ) {
        legacyRenderer( pdomRoot, viewContainers[ VIEW_MODES.LEGACY ] );
      }
    }

    /**
     * Observes the PDOM for changes and throttles re-rendering of the various DOM views.
     *
     * @param {HTMLElement} pdomRoot
     * @param {Object.<string, HTMLElement|null>} viewContainers
     * @param {MutationObserverInit} mutationConfig
     * @param {Object.<string, Function>} renderers
     */
    function addPDOMObserver( pdomRoot, viewContainers, mutationConfig, renderers ) {
      let dirty = true;
      let renderTimeoutId = null;

      const scheduleRender = () => {
        if ( renderTimeoutId !== null ) {
          return;
        }
        renderTimeoutId = setTimeout( () => {
          renderViews( pdomRoot, viewContainers, renderers );
          dirty = false;
          renderTimeoutId = null;
        }, 10 );
      };

      setInterval( () => {
        if ( dirty ) {
          scheduleRender();
        }
      }, 300 );

      const domObserver = new MutationObserver( () => {
        dirty = true;
      } );

      domObserver.observe( pdomRoot, mutationConfig );
      scheduleRender();
    }

    /**
     * Converts inline ARIA metadata into visible markup in the legacy view so the information is easy to inspect.
     *
     * @param {HTMLElement} rootNode - Root whose descendants will be processed.
     */
    function addInlineAttributesTHTML( rootNode ) {

      // all elements in the PDOM - a defensive copy since we may be adding new elements to the DOM
      const allElements = Array.prototype.slice.call( rootNode.getElementsByTagName( '*' ) );

      for ( let i = 0; i < allElements.length; i++ ) {
        const element = allElements[ i ];

        // this check works because PDOMInstance sets hidden on the entire subtree of PDOMInstances when not visible on
        // an accessible display rather than just the hidden ancestor
        if ( !element.hidden ) {
          if ( element.hasAttribute( 'aria-label' ) && element.innerHTML === '' ) {
            const ariaLabel = element.getAttribute( 'aria-label' );

            // remove the style
            element.removeAttribute( 'style' );

            if ( element.tagName.toLowerCase() === 'input' ) {
              if ( element.type === 'button' ) {

                // set the value of the input to be the same as the aria-label appears inside the button
                element.setAttribute( 'value', ariaLabel );
              }
              else {

                // add a special label element to appear before the input element
                const labelElement = document.createElement( 'label' );
                labelElement.textContent = ariaLabel;
                const parentElement = element.parentNode;
                parentElement.insertBefore( labelElement, parentElement.firstChild );
              }
            }
            else {

              // if not an input, then add it to the innerHTML of an element, without overriding what is already there.
              element.innerHTML = ariaLabel + element.innerHTML;
            }
          }

          IMPORTANT_ARIA_ATTRIBUTES.forEach( attributeDefinition => {
            const config = typeof attributeDefinition === 'string' ? { name: attributeDefinition } : attributeDefinition;
            const attributeName = config.name;
            const shouldDisplay = config.shouldDisplay;

            if ( element.hasAttribute( attributeName ) ) {
              const value = element.getAttribute( attributeName );

              if ( shouldDisplay && !shouldDisplay( value, element ) ) {
                return;
              }

              const displayValue = formatAriaValue( config, value, element );

              // add a new element to the DOM that displays the value of the attribute
              const valueElement = document.createElement( 'p' );

              // Assign a className so that we can avoid removing this specific styling when we present the PDOM copy
              valueElement.className = 'pdom-style';
              valueElement.style.opacity = 0.55;
              valueElement.style.display = 'inline-block';
              valueElement.style.paddingLeft = '1em';
              valueElement.textContent = `(${attributeName}: ${displayValue})`;

              // insert directly after the element that has the attribute. This handles the case if element is last, see https://stackoverflow.com/questions/4793604/how-to-insert-an-element-after-another-element-in-javascript-without-using-a-lib
              element.parentNode.insertBefore( valueElement, element.nextSibling );
            }
          } );
        }
      }
    }

    /**
     * Adds a mutation observer to mirror ARIA live region updates in the activity log UI.
     *
     * @param {HTMLElement} originalElement
     * @param {HTMLElement} listElement
     * @param {HTMLElement} alertContainer
     * @param {MutationObserverInit} mutationConfig
     */
    function addLiveObserver( originalElement, listElement, alertContainer, mutationConfig ) {
      if ( !originalElement || !listElement || !alertContainer ) {
        return;
      }
      const liveObserver = new MutationObserver( mutations => {
        mutations.forEach( mutation => {

          // Only display added DOM nodes. ariaLiveAnnouncer will remove the content from aria-live elements so that it
          // can't be read by the virtual cursor. This registers as a "mutation", but we don't want to display
          // the removal.
          if ( mutation.addedNodes.length > 0 ) {
            const alertText = mutation.target.textContent;

            // update the text content of the copied element to match the element in the iframe document
            // create a list item to add to the alert list
            if ( alertText.length > 0 ) {
              const listItem = document.createElement( 'li' );
              listItem.style.opacity = 1.0;
              listItem.textContent = alertText;
              if ( mutation.target.id.includes( 'assertive' ) ) {
                listItem.classList.add( 'assertive' );
              }

              listElement.appendChild( listItem );

              // Auto-scroll to bottom to show the newest messages
              alertContainer.scrollTop = alertContainer.scrollHeight;

              // Remove the oldest items from the list if we are over the limit.
              const overflow = listElement.children.length - ACTIVITY_LOG_LENGTH;
              for ( let i = 0; i < overflow; i++ ) {

                // remove the first child, which is the oldest
                listElement.removeChild( listElement.firstChild );
              }

            }
          }
        } );
      } );

      liveObserver.observe( originalElement, mutationConfig );
    }

    /**
     * Removes all alerts from the activity log container.
     *
     * @param {HTMLElement} listElement
     */
    function clearActivityLog( listElement ) {
      while ( listElement.firstChild ) {
        listElement.removeChild( listElement.lastChild );
      }
    }

    /**
     * Sets up the activity log clear button to remove all logged alerts on click.
     *
     * @param {HTMLElement|null} button
     * @param {HTMLElement|null} listElement
     */
    function initializeActivityLogButton( button, listElement ) {
      if ( !button || !listElement ) {
        return;
      }
      button.addEventListener( 'click', () => clearActivityLog( listElement ) );
    }

    /**
     * Subscribes to iframe load events, wiring DOM observers and view renderers once the sim is ready.
     *
     * @param {{ iframe: HTMLIFrameElement|null, alertList: HTMLElement|null, alertContainer: HTMLElement|null, clearActivityLogButton: HTMLElement|null, viewModeControls: HTMLElement|null, domCopyContainer: HTMLElement|null }} domRefs
     * @param {Object.<string, HTMLElement|null>} viewContainers
     * @param {Object.<string, Function>} renderers
     * @param {MutationObserverInit} mutationConfig
     */
    function setupMessageListener( domRefs, viewContainers, renderers, mutationConfig ) {
      if ( !domRefs || !domRefs.iframe ) {
        return;
      }

      window.addEventListener( 'message', event => {
        if ( !event.data ) {
          return;
        }

        let data;
        try {
          data = JSON.parse( event.data );
        }
        catch( e ) {
          return;
        }

        if ( data.type !== 'load' ) {
          return;
        }

        const innerWindow = domRefs.iframe.contentWindow;
        if ( !innerWindow ) {
          return;
        }

        // eslint-disable-next-line dot-notation
        const phetNamespace = innerWindow[ 'phet' ];
        if ( !phetNamespace || !phetNamespace.joist || !phetNamespace.joist.display ) {
          return;
        }

        // eslint-disable-next-line dot-notation
        const PDOMRoot = phetNamespace.joist.display.pdomRootElement;
        if ( !PDOMRoot ) {
          return;
        }

        // eslint-disable-next-line dot-notation
        const ariaLiveElementsContainer = phetNamespace.joist.sim.display.descriptionUtteranceQueue.announcer.ariaLiveContainer;
        // eslint-disable-next-line dot-notation
        const globalContainer = phetNamespace.scenery.globalDescriptionQueue.announcer.ariaLiveContainer;

        const simDisplayElements = Array.prototype.slice.call( ariaLiveElementsContainer.children );
        const globalElements = Array.prototype.slice.call( globalContainer.children );
        const allSourceAriaLiveElements = [ ...simDisplayElements, ...globalElements ];

        addPDOMObserver( PDOMRoot, viewContainers, mutationConfig, renderers );

        if ( domRefs.alertList && domRefs.alertContainer ) {
          for ( let i = 0; i < allSourceAriaLiveElements.length; i++ ) {
            addLiveObserver( allSourceAriaLiveElements[ i ], domRefs.alertList, domRefs.alertContainer, mutationConfig );
          }
        }

        const iframeDocument = domRefs.iframe.contentWindow.document;

        domRefs.iframe.focus();

        let previousElement = null;
        const handleIframeFocus = () => {
          if ( previousElement ) {
            previousElement.classList.remove( 'highlight' );
          }
          const activeElement = iframeDocument.activeElement;
          previousElement = activeElement;
          const isDocumentBody = activeElement === iframeDocument.body;
          if ( activeElement && !isDocumentBody && typeof activeElement.classList !== 'undefined' ) {
            activeElement.classList.add( 'highlight' );
          }
          currentFocusedElement = !isDocumentBody ? activeElement : null;
          refreshDevelopmentFocusHighlight();
        };

        iframeDocument.addEventListener( 'focusin', handleIframeFocus );
        handleIframeFocus();
      } );
    }

    /**
     * Collects frequently accessed DOM nodes for later use.
     *
     * @returns {{ iframe: HTMLIFrameElement|null, alertList: HTMLElement|null, alertContainer: HTMLElement|null, clearActivityLogButton: HTMLElement|null, viewModeControls: HTMLElement|null, domCopyContainer: HTMLElement|null }}
     */
    function createDomReferences() {
      return {
        iframe: document.getElementById( 'iframe' ),
        alertList: document.getElementById( 'alert-list' ),
        alertContainer: document.getElementById( 'alert-copy-container' ),
        clearActivityLogButton: document.getElementById( 'clear-activity-log-button' ),
        viewModeControls: document.getElementById( 'view-mode-controls' ),
        domCopyContainer: document.getElementById( 'dom-copy-container' )
      };
    }

    /**
     * Resolves the specific DOM view containers under the provided root element.
     *
     * @param {HTMLElement|null} root
     * @returns {{ formatted: HTMLElement|null, development: HTMLElement|null, legacy: HTMLElement|null }}
     */
    function createViewContainers( root ) {
      if ( !root ) {
        return {
          formatted: null,
          development: null,
          legacy: null
        };
      }

      return {
        formatted: root.querySelector( '[data-view="formatted"]' ),
        development: root.querySelector( '[data-view="development"]' ),
        legacy: root.querySelector( '[data-view="legacy"]' )
      };
    }

    /**
     * Enables live-reload updates for local development when the query parameter is present.
     */
    function initializeLiveReload() {
      const query = new URLSearchParams( window.location.search );
      if ( !query.has( 'liveReload' ) ) {
        return;
      }
      new EventSource( '/esbuild' ).addEventListener( 'change', () => location.reload() );
    }

  } )();
</script>
</body>
</html>
