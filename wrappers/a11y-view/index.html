<!DOCTYPE HTML>
<!-- Top-level HTML file for viewing, generated by 'grunt generate-a11y-view-html' DO NOT EDIT THIS FILE ONCE BUILT-->
<html>
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="phet-sim-level" content="production">

  <!--have to scroll right and left! allows to resize also-->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A11y View</title>

  <style>
    html {
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.4;
    }

    body {
      margin: 1em;
      background: #ccc;
    }

    h1, h3, p {
      margin-top: .55em;
      margin-bottom: 0;
      padding: 0;
    }

    .alert_copy_container ul {
      -webkit-padding-start: 1.1em
    }

    .left {
      width: 47%;
      position: -webkit-sticky;
      position: sticky;
      top: .55em;
      display: inline-block;
    }

    /* This class was found online as a way to preserve an iframe aspect ratio,
    see https://fettblog.eu/blog/2013/06/16/preserving-aspect-ratio-for-embedded-iframes/*/

    iframe {
      width: 100%;
      position: fixed;
    }

    .aspect-ratio {
      position: relative;
      width: 100%;
      height: 0;
      padding-bottom: 69%;
    }

    .aspect-ratio iframe {
      position: absolute;
      width: 100%;
      height: 100%;
      left: 0;
      top: 0;
    }

    div.right {
      background: #ccc;
      float: right;
      width: 47%;
      overflow: auto;
    }

    div.clearfix {
      clear: both;
    }

    p.alert {
      opacity: 0.6;
    }

    div.alert_copy_container {
      background: #e5c45b;
      border-radius: 1em;
      padding: .25em .75em 1em;
      height: 10em;
      overflow-y: auto;
    }

    p.alert_copy {
      min-height: 5em;
    }

    div.dom_copy_container {
      background: #a0e1e7;
      border-radius: 1em;
      padding: 1em;
    }

    div.dom_copy_container li {
      margin-bottom: .5em;
    }

    div.wrapper {
      height: auto;
      width: 97%;
    }

    .dynamic {
      background-color: #9adaa6;
      border-bottom: double .167em #000; /*or a border in dark green*/
    }

    div#alerts, div#pdom {
      margin-bottom: 1.1em;
    }

    em { /* this is the same as the dynamic class, but should be changed as part of https://github.com/phetsims/a11y-research/issues/67*/
      background-color: #9adaa6;
      border-bottom: double .167em #000; /*or a border in dark green*/
    }

    .highlight {
      /*use outline instead of border because border doesn't apply to all DOMElements, add margin because outline
      doesn't take up any space*/
      outline: thick double red;
      margin: 1%;
    }

    .bold {
      font-weight: bold;
    }

    .assertive {
      background-color: pink; /* do not change color without changing the doc in "About Interactive Alerts" */
      border-radius: .2em;
    }

    .activity-log-heading-container {
      display: flex;
      align-content: space-between;
      align-items: flex-start;
      justify-content: space-between;
      padding-top: 0.5em;
    }

    .activity-log-heading-item {
      align-self: center;
      font-size: 1.17em;
    }

    .view-mode-controls {
      display: flex;
      gap: 0.75em;
      flex-wrap: wrap;
      padding: 0.75em 1em 0.5em;
      background: #ecf4fb;
      border-radius: 0.75em;
      margin-bottom: 1em;
    }

    .view-mode-option {
      display: flex;
      align-items: center;
      gap: 0.35em;
      font-size: 0.95em;
    }

    .view-mode-option input[type="radio"] {
      accent-color: #0a74b9;
    }

    .dom-view {
      display: none;
    }

    .dom-view[data-active="true"] {
      display: block;
    }

    .formatted-entry {
      border-left: 3px solid #c0d4e6;
      padding: 0.5em 0.75em;
      border-radius: 0.35em;
      margin-bottom: 0.5em;
      background-color: #f8fcff;
    }

    .formatted-entry-title {
      font-weight: 600;
      color: #134575;
      margin-bottom: 0.25em;
    }

    .formatted-entry-text {
      color: #1c1c1c;
    }

    .formatted-entry-metadata {
      margin-top: 0.35em;
      font-size: 0.85em;
      color: #3a3a3a;
      opacity: 0.7;
    }

    .development-container {
      font-family: "Courier New", Courier, monospace;
      background: #0f111a;
      color: #d8dee9;
      padding: 0.75em 1em;
      border-radius: 0.75em;
      overflow-x: auto;
    }

    .development-line {
      white-space: pre;
    }

    .development-tag {
      color: #7285a8;
    }

    .development-attribute {
      color: #9fb4d9;
    }

    .development-attribute-value {
      color: #d9c27f;
    }

    .development-text-node {
      color: #f5f7fa;
    }

    /* ************SAFARI ONLY *********************** */
    .left-safari {
      display: inline-block;
      width: 47%;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
  </style>

</head>
<body>

<div class="wrapper">

  <div id="content">
    <div id="intro">
      <h1>A11y View</h1>
      <details>
        <summary>About the A11y View Tool</summary>
        <p>
          The A11y View is a design and presentation tool that visually displays a copy of the descriptions we design
          for the Interactive Description feature. The State Descriptions (blue box) track the current state of the
          simulation. The Responsive Descriptions (orange box) deliver relevant changes in real time as they happen.
          Using this tool, designers can test and assess the descriptions during the design process without using a
          screen reader. Educators can also use this tool to see if the content of the descritpions meets their teaching
          and learning needs.
        </p>
        <p>
          <b>Please note:</b> The A11y View is not for learners. In learning contexts, screen reader users access the
          Interactive Desctiption feature using the same simulation as everyone else.
        </p>
      </details>
    </div>

    <!--The sim and alert containers will both be placed in here -->
    <div id="left" class="left">
      <div class="aspect-ratio">
        <iframe id="iframe" allowfullscreen scrolling="no" title="Interact with simulation"></iframe>
      </div>
      <div id="alerts">
        <div class="activity-log-heading-container">
          <h3 class="activity-log-heading-item">Activity log of Responsive Descriptions</h3>
          <button class="activity-log-heading-item" id="clear-activity-log-button">Clear Log</button>
        </div>
        <details>
          <summary>About Responsive Descriptions</summary>
          Responsive Descriptions are a combination of object responses, descriptions of changes made directly to
          interactive objects, and context responses, descriptions of changes to the surrounding context. Together, they
          are designed to deliver relevant changes in real time as they happen. The object and context responses powered
          by ARIA Live appear in the activity log below. The object responses for slider interactions are powered by the
          aria-valuetext attribute, and are found in grey text under slider interactions in the blue box.
        </details>
        <div id='alert-copy-container' class='alert_copy_container' role='presentation'>
          <div id='polite-element-container'>
            <ul class='alert_copy' id='alert-list'></ul>
          </div>
        </div>
      </div>
    </div>

    <!--The PDOM copy will be placed in this container -->
    <div class="right" id="right">
      <div id="pdom">
        <h3>State Descriptions</h3>
        <details>
          <summary>About State Descriptions</summary>
          State Descriptions are a combination of static state descriptions (descriptions that never change) and dynamic
          state descriptions (descriptions that update silently as the simulation changes). Together, they form a
          complete description of the current state at any given moment. These are the descriptions that a screen reader
          user can read through or review as they feel the need when they are accessing a simulation (i.e., not the A11y
          View tool).
        </details>
        <div class="dom_copy_container" role="presentation">
          <fieldset id="view-mode-controls" class="view-mode-controls" role="radiogroup" aria-label="View mode">
            <legend class="sr-only">Select view mode</legend>
            <label class="view-mode-option">
              <input type="radio" name="a11y-view-mode" value="formatted">
              Formatted view
            </label>
            <label class="view-mode-option">
              <input type="radio" name="a11y-view-mode" value="development">
              Development view
            </label>
            <label class="view-mode-option">
              <input type="radio" name="a11y-view-mode" value="legacy">
              Legacy view
            </label>
          </fieldset>
          <div id="dom-copy-container">
            <div class="dom-view" data-view="formatted"></div>
            <div class="dom-view" data-view="development"></div>
            <div class="dom-view" data-view="legacy"></div>
          </div>
        </div>
      </div>
    </div>

    <!--clear the blocks after the float effect-->
    <div class="clearfix"></div>
  </div>

</div>

<script type="application/javascript">
  const IS_BUILT_STRING = '{{IS_BUILT}}';
  const IS_BUILT = IS_BUILT_STRING.indexOf( '{{' ) !== 0; // escape for better syntax highlighting support

  const simulationQueryString = new URLSearchParams( window.location.search );

  // TODO: This code is very PhET-sim specific, we would like a way to specify an arbitrary scenery-stack app
  // TODO: https://github.com/phetsims/chipper/issues/1512
  let sim = simulationQueryString.get( 'sim' );

  // Remove the sim query parameter from the URL so that it doesn't go to the iframe url
  simulationQueryString.delete( 'sim' );

  // Do not liveReload on the nested iframe, just in the outer a11y view.
  simulationQueryString.delete( 'liveReload' );

  // Append the required parameters.
  simulationQueryString.set( 'postMessageOnLoad', '' );
  simulationQueryString.set( 'postMessageOnError', '' );
  simulationQueryString.set( 'supportsInteractiveDescription', 'true' );

  // in unbuilt mode and on phet-server, the brand suffix is removed
  const filenameEnding = ( window.location.hostname === 'phet.colorado.edu' || !IS_BUILT ) ? '.html' : '_phet.html';

  if ( IS_BUILT ) {
    sim = '{{PHET_REPOSITORY}}';
  }
  if ( !sim ) {
    throw new Error( 'No sim query parameter provided' );
  }

  // Unbuilt sims include all locales in the en file, built versions only include all strings in the all file
  const simWithLocale = `${sim}_${IS_BUILT ? 'all' : 'en'}`;
  let simURL = `../../../${sim}/${simWithLocale}${filenameEnding}?${simulationQueryString}`;

  if ( IS_BUILT ) {
    simURL = `./${simWithLocale}${filenameEnding}?${simulationQueryString}`;
  }

  // set the source of the sim iframe
  document.getElementById( 'iframe' ).setAttribute( 'src', simURL );

  // apply sticky styling for all browsers except chrome.
  const left = document.getElementById( 'left' );
  const ua = navigator.userAgent.toLowerCase();
  if ( ua.indexOf( 'safari' ) !== -1 ) {
    if ( ua.indexOf( 'chrome' ) > -1 ) {
      left.classList.add( 'left' );
    }
    else {
      left.classList.add( 'left-safari' );
    }
  }

</script>

<script>
  // Number of alerts that remain in the Activity log
  const ACTIVITY_LOG_LENGTH = 40;

  // The attributes that we want to display as additional data in the PDOM copy. Otherwise, these are invisible
  // unless you inspect the DOM. For each entry, you can provide a shouldDisplay predicate that will control
  // how it is shown.
  const IMPORTANT_ARIA_ATTRIBUTES = [
    { name: 'aria-valuetext' },
    { name: 'aria-expanded' },
    { name: 'aria-pressed' },
    { name: 'aria-roledescription' },
    { name: 'role' },
    {
      name: 'aria-disabled',

      // aria-disabled: false is too noisy to show so it is hidden
      shouldDisplay: value => value === 'true'
    }
  ];

  const VIEW_MODES = {
    FORMATTED: 'formatted',
    DEVELOPMENT: 'development',
    LEGACY: 'legacy'
  };

  const VIEW_MODE_STORAGE_KEY = 'a11y-view-mode';
  const DEFAULT_VIEW_MODE = VIEW_MODES.FORMATTED;

  const DEVELOPMENT_ALLOWED_ATTRIBUTES = new Set( [
    'role',
    'type',
    'name',
    'value',
    'checked',
    'disabled',
    'required',
    'hidden',
    'title',
    'alt',
    'lang',
    'for',
    'placeholder',
    'min',
    'max',
    'step'
  ] );

  const VOID_ELEMENTS = new Set( [
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr'
  ] );

  /*******************************************************************************
   * Helper Functions
   */

  /**
   * Get all 'element' nodes off the parent element, placing them in an array for easy traversal.  Note that this
   * includes all elements, even those that are 'hidden' or purely for structure.
   *
   * @param  {HTMLElement} ancestor - parent whose children will be linearized
   * @returns {HTMLElement[]}
   */
  function getAllDOMElementsAsLinear( ancestor ) {

    // gets ALL descendant children for the element
    const children = ancestor.getElementsByTagName( '*' );

    const linearDOM = [];
    for ( let i = 0; i < children.length; i++ ) {

      // searching for the HTML element nodes (NOT Scenery nodes)
      if ( children[ i ].nodeType === Node.ELEMENT_NODE ) {
        linearDOM[ i ] = ( children[ i ] );
      }
    }
    return linearDOM;
  }

  /**
   * Apply the necessary styling to the PDOM copy so that it looks and behaves well. This includes removing from
   * navigation order and ensuring that all of the styling copied from the actual PDOM is removed so that the copy
   * is visible and elements have proper dimensions.
   *
   * @param {HTMLElement} root - ancestor element, this and all descendants will be styled
   */
  function styleCopy( root ) {
    const allElements = getAllDOMElementsAsLinear( root );

    for ( let i = 0; i < allElements.length; i++ ) {
      const element = allElements[ i ];

      // make sure nothing in copy is focusable
      element.tabIndex = '-1';

      // make sure that styling is removed, unless some styling was added just for the copy
      if ( element.className !== 'pdom-style' ) {
        element.removeAttribute( 'style' );
      }
    }
  }

  function setActiveView( viewContainers, viewMode ) {
    Object.keys( viewContainers ).forEach( key => {
      const container = viewContainers[ key ];
      if ( !container ) {
        return;
      }
      if ( key === viewMode ) {
        container.setAttribute( 'data-active', 'true' );
      }
      else {
        container.removeAttribute( 'data-active' );
      }
    } );
  }

  function loadViewMode() {
    try {
      const value = localStorage.getItem( VIEW_MODE_STORAGE_KEY );
      if ( value && Object.values( VIEW_MODES ).includes( value ) ) {
        return value;
      }
    }
    catch( e ) {
      // ignore storage errors, fall back to default
    }
    return DEFAULT_VIEW_MODE;
  }

  function storeViewMode( viewMode ) {
    try {
      localStorage.setItem( VIEW_MODE_STORAGE_KEY, viewMode );
    }
    catch( e ) {
      // ignore storage failures
    }
  }

  function initializeViewModeControls( viewContainers ) {
    const controls = document.getElementById( 'view-mode-controls' );
    if ( !controls ) {
      return DEFAULT_VIEW_MODE;
    }

    const radioButtons = controls.querySelectorAll( 'input[name="a11y-view-mode"]' );
    let currentMode = loadViewMode();

    radioButtons.forEach( radio => {
      if ( radio.value === currentMode ) {
        radio.checked = true;
      }

      radio.addEventListener( 'change', event => {
        if ( event.target.checked ) {
          currentMode = event.target.value;
          storeViewMode( currentMode );
          setActiveView( viewContainers, currentMode );
        }
      } );
    } );

    if ( !Array.from( radioButtons ).some( radio => radio.checked ) ) {
      const firstRadio = Array.from( radioButtons )[ 0 ];
      if ( firstRadio ) {
        currentMode = firstRadio.value;
        firstRadio.checked = true;
      }
    }

    setActiveView( viewContainers, currentMode );
    return currentMode;
  }

  function renderLegacyView( pdomRoot, container ) {
    if ( !container ) {
      return;
    }
    container.innerHTML = '';
    const pdomCopy = pdomRoot.cloneNode( true );
    pdomCopy.removeAttribute( 'style' );
    container.appendChild( pdomCopy );
    addInlineAttributesTHTML( pdomCopy );
    styleCopy( pdomCopy );
  }

  function renderFormattedView( pdomRoot, container ) {
    if ( !container ) {
      return;
    }
    container.innerHTML = '';
    const fragment = document.createDocumentFragment();
    const roots = Array.from( pdomRoot.children );

    roots.forEach( child => buildFormattedEntry( child, fragment, 0 ) );

    if ( fragment.childNodes.length === 0 ) {
      const emptyMessage = document.createElement( 'p' );
      emptyMessage.textContent = 'No accessible content available.';
      fragment.appendChild( emptyMessage );
    }

    container.appendChild( fragment );
  }

  function shouldSkipFormattedElement( element ) {
    if ( !element || element.nodeType !== Node.ELEMENT_NODE ) {
      return true;
    }
    if ( element.hidden || element.getAttribute( 'aria-hidden' ) === 'true' ) {
      return true;
    }
    const tagName = element.tagName;
    return tagName === 'SCRIPT' || tagName === 'STYLE' || tagName === 'TEMPLATE';
  }

  function buildFormattedEntry( element, parent, depth ) {
    if ( shouldSkipFormattedElement( element ) ) {
      return;
    }

    const entry = document.createElement( 'div' );
    entry.className = 'formatted-entry';
    entry.style.marginLeft = `${depth * 1.25}em`;

    const title = document.createElement( 'div' );
    title.className = 'formatted-entry-title';
    title.textContent = getFormattedTitle( element );
    entry.appendChild( title );

    const primaryText = getPrimaryFormattedText( element );
    if ( primaryText ) {
      const textLine = document.createElement( 'div' );
      textLine.className = 'formatted-entry-text';
      textLine.textContent = primaryText;
      entry.appendChild( textLine );
    }

    const metadataItems = getFormattedMetadata( element );
    if ( metadataItems.length > 0 ) {
      const metadataLine = document.createElement( 'div' );
      metadataLine.className = 'formatted-entry-metadata';
      metadataLine.textContent = metadataItems.join( ' · ' );
      entry.appendChild( metadataLine );
    }

    parent.appendChild( entry );
    Array.from( element.children ).forEach( child => buildFormattedEntry( child, parent, depth + 1 ) );
  }

  function getFormattedTitle( element ) {
    if ( element.hasAttribute( 'aria-roledescription' ) ) {
      return toTitleCase( element.getAttribute( 'aria-roledescription' ) );
    }

    if ( element.hasAttribute( 'role' ) ) {
      return formatRoleName( element.getAttribute( 'role' ) );
    }

    const tagName = element.tagName.toLowerCase();
    if ( /^h[1-6]$/.test( tagName ) ) {
      return `Heading level ${tagName.charAt( 1 )}`;
    }

    const tagLabels = {
      button: 'Button',
      input: `Input${element.type ? ` (${element.type})` : ''}`,
      p: 'Paragraph',
      li: 'List item',
      ul: 'List',
      ol: 'Ordered list',
      label: 'Label',
      span: 'Span',
      section: 'Section',
      article: 'Article',
      div: 'Group'
    };

    return tagLabels[ tagName ] || toTitleCase( tagName );
  }

  function formatRoleName( role ) {
    if ( !role ) {
      return 'Element';
    }
    return role.split( /\s+/ ).map( toTitleCase ).join( ', ' );
  }

  function toTitleCase( text ) {
    return text.replace( /\w\S*/g, chunk => chunk.charAt( 0 ).toUpperCase() + chunk.slice( 1 ).toLowerCase() );
  }

  function getPrimaryFormattedText( element ) {
    if ( element.hasAttribute( 'aria-label' ) ) {
      return element.getAttribute( 'aria-label' );
    }

    if ( element.tagName.toLowerCase() === 'input' ) {
      const type = element.getAttribute( 'type' );
      if ( type === 'button' || type === 'submit' || type === 'reset' ) {
        return element.getAttribute( 'value' ) || '';
      }
    }

    const directText = getDirectTextContent( element );
    if ( directText ) {
      return directText;
    }

    if ( element.tagName.toLowerCase() === 'img' && element.hasAttribute( 'alt' ) ) {
      return element.getAttribute( 'alt' );
    }

    return '';
  }

  function getDirectTextContent( element ) {
    return Array.from( element.childNodes )
      .filter( node => node.nodeType === Node.TEXT_NODE )
      .map( node => node.textContent.replace( /\s+/g, ' ' ).trim() )
      .filter( text => text.length > 0 )
      .join( ' ' );
  }

  function getFormattedMetadata( element ) {
    const metadata = [];

    IMPORTANT_ARIA_ATTRIBUTES.forEach( attributeDefinition => {
      const config = typeof attributeDefinition === 'string' ? { name: attributeDefinition } : attributeDefinition;
      const attributeName = config.name;
      const shouldDisplay = config.shouldDisplay;

      if ( attributeName === 'role' ) {
        return;
      }

      if ( element.hasAttribute( attributeName ) ) {
        const value = element.getAttribute( attributeName );

        if ( shouldDisplay && !shouldDisplay( value, element ) ) {
          return;
        }

        metadata.push( `${attributeName}: ${value}` );
      }
    } );

    if ( element.hasAttribute( 'aria-describedby' ) ) {
      const references = element.getAttribute( 'aria-describedby' ).trim().split( /\s+/ ).filter( token => token.length > 0 );
      if ( references.length > 0 ) {
        metadata.push( `Describes: ${references.length}` );
      }
    }

    return metadata;
  }

  function renderDevelopmentView( pdomRoot, container ) {
    if ( !container ) {
      return;
    }
    container.innerHTML = '';

    const wrapper = document.createElement( 'div' );
    wrapper.className = 'development-container';

    const workingCopy = pdomRoot.cloneNode( true );
    sanitizeForDevelopmentView( workingCopy );

    const topLevelElements = Array.from( workingCopy.children );
    topLevelElements.forEach( element => renderDevelopmentNode( element, wrapper, 0 ) );

    if ( wrapper.childNodes.length === 0 ) {
      wrapper.textContent = 'No accessible markup available.';
    }

    container.appendChild( wrapper );
  }

  function sanitizeForDevelopmentView( root ) {

    // Remove hidden elements entirely from the view.
    Array.from( root.querySelectorAll( '[hidden]' ) ).forEach( element => {
      if ( element.parentNode ) {
        element.parentNode.removeChild( element );
      }
    } );

    const walker = document.createTreeWalker( root, NodeFilter.SHOW_ELEMENT, null );
    while ( walker.nextNode() ) {
      sanitizeElement( walker.currentNode );
    }
  }

  function sanitizeElement( element ) {
    Array.from( element.attributes ).forEach( attribute => {
      const name = attribute.name;
      const value = attribute.value;

      if ( name === 'class' || name === 'style' || name.startsWith( 'data-' ) ) {
        element.removeAttribute( name );
        return;
      }

      if ( name === 'tabindex' ) {
        element.removeAttribute( name );
        return;
      }

      if ( name === 'id' || name === 'hidden' ) {
        element.removeAttribute( name );
        return;
      }

      if ( name.startsWith( 'aria-' ) || DEVELOPMENT_ALLOWED_ATTRIBUTES.has( name ) ) {
        if ( ( name === 'aria-describedby' || name === 'aria-labelledby' || name === 'aria-controls' || name === 'aria-owns' || name === 'aria-activedescendant' || name === 'for' ) && value ) {
          element.setAttribute( name, '...' );
        }
        return;
      }

      element.removeAttribute( name );
    } );
  }

  function renderDevelopmentNode( element, container, depth ) {
    const tagName = element.tagName.toLowerCase();
    const indent = `${depth * 1.25}em`;

    const openLine = document.createElement( 'div' );
    openLine.className = 'development-line';
    openLine.style.marginLeft = indent;
    openLine.appendChild( createTagSpan( `<${tagName}` ) );

    const attributes = Array.from( element.attributes ).sort( ( a, b ) => a.name.localeCompare( b.name ) );
    attributes.forEach( attribute => appendAttributeTokens( openLine, attribute ) );

    if ( VOID_ELEMENTS.has( tagName ) ) {
      openLine.appendChild( createTagSpan( ' />' ) );
      container.appendChild( openLine );
      return;
    }

    openLine.appendChild( createTagSpan( '>' ) );
    container.appendChild( openLine );

    Array.from( element.childNodes ).forEach( node => {
      if ( node.nodeType === Node.ELEMENT_NODE ) {
        renderDevelopmentNode( node, container, depth + 1 );
      }
      else if ( node.nodeType === Node.TEXT_NODE ) {
        renderDevelopmentTextNode( node, container, depth );
      }
    } );

    const closeLine = document.createElement( 'div' );
    closeLine.className = 'development-line';
    closeLine.style.marginLeft = indent;
    closeLine.appendChild( createTagSpan( `</${tagName}>` ) );
    container.appendChild( closeLine );
  }

  function createTagSpan( text ) {
    const span = document.createElement( 'span' );
    span.className = 'development-tag';
    span.textContent = text;
    return span;
  }

  function appendAttributeTokens( line, attribute ) {
    line.appendChild( document.createTextNode( ' ' ) );

    const nameSpan = document.createElement( 'span' );
    nameSpan.className = 'development-attribute';
    nameSpan.textContent = attribute.name;
    line.appendChild( nameSpan );

    if ( attribute.value ) {
      const equalsSpan = document.createElement( 'span' );
      equalsSpan.className = 'development-tag';
      equalsSpan.textContent = '=';
      line.appendChild( equalsSpan );

      const valueSpan = document.createElement( 'span' );
      valueSpan.className = 'development-attribute-value';
      valueSpan.textContent = `"${attribute.value}"`;
      line.appendChild( valueSpan );
    }
  }

  function renderDevelopmentTextNode( node, container, depth ) {
    const content = node.textContent.replace( /\s+/g, ' ' ).trim();
    if ( !content ) {
      return;
    }

    const textLine = document.createElement( 'div' );
    textLine.className = 'development-line';
    textLine.style.marginLeft = `${( depth + 1 ) * 1.25}em`;

    const span = document.createElement( 'span' );
    span.className = 'development-text-node';
    span.textContent = content;
    textLine.appendChild( span );
    container.appendChild( textLine );
  }

  function renderViews( pdomRoot, viewContainers ) {
    renderFormattedView( pdomRoot, viewContainers[ VIEW_MODES.FORMATTED ] );
    renderDevelopmentView( pdomRoot, viewContainers[ VIEW_MODES.DEVELOPMENT ] );
    renderLegacyView( pdomRoot, viewContainers[ VIEW_MODES.LEGACY ] );
  }

  function addPDOMObserver( pdomRoot, viewContainers, mutationConfig ) {
    let dirty = true;
    let renderTimeoutId = null;

    const scheduleRender = () => {
      if ( renderTimeoutId !== null ) {
        return;
      }
      renderTimeoutId = setTimeout( () => {
        renderViews( pdomRoot, viewContainers );
        dirty = false;
        renderTimeoutId = null;
      }, 10 );
    };

    setInterval( () => {
      if ( dirty ) {
        scheduleRender();
      }
    }, 300 );

    const domObserver = new MutationObserver( () => {
      dirty = true;
    } );

    domObserver.observe( pdomRoot, mutationConfig );
    scheduleRender();
  }

  /**
   * Convert the inline ARIA labels with label information to input values or additional label elements in the
   * PDOM copy so that they are visible in demonstrations. For example, this could be an aria-label, aria-valuetext,
   * and so on.
   *
   * @param {HTMLElement} rootNode - descendants of this root are traversed so we have
   */
  function addInlineAttributesTHTML( rootNode ) {

    // all elements in the PDOM - a defensive copy since we may be adding new elements to the DOM
    const allElements = Array.prototype.slice.call( rootNode.getElementsByTagName( '*' ) );

    for ( let i = 0; i < allElements.length; i++ ) {
      const element = allElements[ i ];

      // this check works because PDOMInstance sets hidden on the entire subtree of PDOMInstances when not visible on
      // an accessible display rather than just the hidden ancestor
      if ( !element.hidden ) {
        if ( element.hasAttribute( 'aria-label' ) && element.innerHTML === '' ) {
          const ariaLabel = element.getAttribute( 'aria-label' );

          // remove the style
          element.removeAttribute( 'style' );

          if ( element.tagName.toLowerCase() === 'input' ) {
            if ( element.type === 'button' ) {

              // set the value of the input to be the same as the aria-label appears inside the button
              element.setAttribute( 'value', ariaLabel );
            }
            else {

              // add a special label element to appear before the input element
              const labelElement = document.createElement( 'label' );
              labelElement.textContent = ariaLabel;
              const parentElement = element.parentNode;
              parentElement.insertBefore( labelElement, parentElement.firstChild );
            }
          }
          else {

            // if not an input, then add it to the innerHTML of an element, without overriding what is already there.
            element.innerHTML = ariaLabel + element.innerHTML;
          }
        }

        IMPORTANT_ARIA_ATTRIBUTES.forEach( attributeDefinition => {
          const config = typeof attributeDefinition === 'string' ? { name: attributeDefinition } : attributeDefinition;
          const attributeName = config.name;
          const shouldDisplay = config.shouldDisplay;

          if ( element.hasAttribute( attributeName ) ) {
            const value = element.getAttribute( attributeName );

            if ( shouldDisplay && !shouldDisplay( value, element ) ) {
              return;
            }

            // add a new element to the DOM that displays the value of the attribute
            const valueElement = document.createElement( 'p' );

            // Assign a className so that we can avoid removing this specific styling when we present the PDOM copy
            valueElement.className = 'pdom-style';
            valueElement.style.opacity = 0.55;
            valueElement.style.display = 'inline-block';
            valueElement.style.paddingLeft = '1em';
            valueElement.textContent = `(${attributeName}: ${value})`;

            // insert directly after the element that has the attribute. This handles the case if element is last, see https://stackoverflow.com/questions/4793604/how-to-insert-an-element-after-another-element-in-javascript-without-using-a-lib
            element.parentNode.insertBefore( valueElement, element.nextSibling );
          }
        } );
      }
    }
  }

  /**
   * add mutation observers to each of the aria-live elements
   * @param {HTMLElement} originalElement
   * @param {HTMLElement} listElement
   * @param {Object} mutationConfig
   */
  function addLiveObserver( originalElement, listElement, mutationConfig ) {
    const liveObserver = new MutationObserver( mutations => {
      mutations.forEach( mutation => {

        // Only display added DOM nodes. ariaLiveAnnouncer will remove the content from aria-live elements so that it
        // can't be read by the virtual cursor. This registers as a "mutation", but we don't want to display
        // the removal.
        if ( mutation.addedNodes.length > 0 ) {
          const alertText = mutation.target.textContent;

          // update the text content of the copied element to match the element in the iframe document
          // create a list item to add to the alert list
          if ( alertText.length > 0 ) {
            const listItem = document.createElement( 'li' );
            listItem.style.opacity = 1.0;
            listItem.textContent = alertText;
            if ( mutation.target.id.includes( 'assertive' ) ) {
              listItem.classList.add( 'assertive' );
            }

            listElement.appendChild( listItem );

            // Auto-scroll to bottom to show the newest messages
            const alertContainer = document.getElementById( 'alert-copy-container' );
            alertContainer.scrollTop = alertContainer.scrollHeight;

            // Remove the oldest items from the list if we are over the limit.
            const overflow = listElement.children.length - ACTIVITY_LOG_LENGTH;
            for ( let i = 0; i < overflow; i++ ) {

              // remove the first child, which is the oldest
              listElement.removeChild( listElement.firstChild );
            }

          }
        }
      } );
    } );

    liveObserver.observe( originalElement, mutationConfig );
  }

  /**
   * Remove all alerts from the activity log by removing all children of the parent containing them. Solution to clear
   * children from https://stackoverflow.com/questions/3955229/remove-all-child-elements-of-a-dom-node-in-javascript
   */
  function clearActivityLog( listElement ) {
    while ( listElement.firstChild ) {
      listElement.removeChild( listElement.lastChild );
    }
  }

  // constants
  // see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserverInit for details
  const MUTATION_OBSERVER_CONFIG = {
    attributes: true,
    childList: true,
    characterData: true,
    subtree: true
  };

  // handling messages from sims
  window.addEventListener( 'message', event => {
    if ( !event.data ) {
      return;
    }

    let data;
    try {
      data = JSON.parse( event.data );
    }
    catch( e ) {
      return;
    }

    // if load is successful, create a visualization of the parallel DOM
    if ( data.type === 'load' ) {

      const simFrame = document.getElementById( 'iframe' );
      const innerWindow = simFrame.contentWindow;
      // eslint-disable-next-line dot-notation
      const PDOMRoot = innerWindow[ 'phet' ].joist.display.pdomRootElement; // copy of the parallel DOM

      // get the alert dom elements from the iframe's inner document
      // eslint-disable-next-line dot-notation
      const ariaLiveElementsContainer = innerWindow[ 'phet' ].joist.sim.display.descriptionUtteranceQueue.announcer.ariaLiveContainer;

      // Add the global aria-live elements as well
      // eslint-disable-next-line dot-notation
      const globalContainer = innerWindow[ 'phet' ].scenery.globalDescriptionQueue.announcer.ariaLiveContainer;

      const simDisplayElements = Array.prototype.slice.call( ariaLiveElementsContainer.children );
      const globalElements = Array.prototype.slice.call( globalContainer.children );
      const allSourceAriaLiveElements = [ ...simDisplayElements, ...globalElements ];

      // get the alert dom elements from the PDOM copy
      const alertList = document.getElementById( 'alert-list' );

      // get the parent container for the parallel DOM copy and the alert content
      const viewContainerRoot = document.getElementById( 'dom-copy-container' );
      const viewContainers = {
        formatted: viewContainerRoot.querySelector( '[data-view="formatted"]' ),
        development: viewContainerRoot.querySelector( '[data-view="development"]' ),
        legacy: viewContainerRoot.querySelector( '[data-view="legacy"]' )
      };
      initializeViewModeControls( viewContainers );

      // update the PDOM copy whenever the sim's PDOM changes
      addPDOMObserver( PDOMRoot, viewContainers, MUTATION_OBSERVER_CONFIG );

      // observe each of the live elements and add new text content to the list view
      for ( let i = 0; i < allSourceAriaLiveElements.length; i++ ) {
        addLiveObserver( allSourceAriaLiveElements[ i ], alertList, MUTATION_OBSERVER_CONFIG );
      }

      // clear all alerts when the "Clear Log" button is pressed
      const clearButton = document.getElementById( 'clear-activity-log-button' );
      clearButton.addEventListener( 'click', () => clearActivityLog( alertList ) );

      const iframe = document.getElementById( 'iframe' );
      const iframeDocument = iframe.contentWindow.document;

      // set focus to the loaded iframe
      iframe.focus();

      let previousElement = null;
      iframeDocument.addEventListener( 'focusin', event => {
        if ( previousElement ) {
          previousElement.classList.remove( 'highlight' );
        }
        previousElement = iframeDocument.activeElement;
        previousElement.classList.add( 'highlight' );
      } );
    }
  } );

  // Live reload, see https://esbuild.github.io/api/#live-reload
  const query = new URLSearchParams( window.location.search );
  const liveReload = !!query.has( 'liveReload' );
  if ( liveReload ) {
    new EventSource( '/esbuild' ).addEventListener( 'change', () => location.reload() );
  }

</script>
</body>
</html>
